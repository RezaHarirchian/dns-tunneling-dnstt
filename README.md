# راه‌اندازی dnstt روی VPS ایران بدون اینترنت بین‌الملل  
تانل DNS امن و نسبتا مقاوم در برابر فیلترینگ

این یک راهنمای عملی برای راه‌اندازی **dnstt** است، در سناریوی مشخص زیر:

- یک **VPS خارج از ایران** با اینترنت آزاد؛  
- یک **VPS داخل ایران** که:
  - دسترسی HTTP/HTTPS بین‌الملل ندارد یا به‌شدت محدود است؛
  - اما هنوز می‌تواند **ترافیک DNS (یا DoH/DoT) به بیرون بفرستد**؛
- هدف: ساخت یک **تانل DNS (dnstt)** بین این دو، و استفاده از آن به‌عنوان زیرساخت عبور از فیلترینگ برای خودتان و در صورت نیاز برای سایر کاربران..

---

## فهرست مطالب

- [۱. ایده‌ی اصلی و سناریوی هدف](#۱-ایده-ی-اصلی-و-سناریوی-هدف)
- [۲. پیش‌نیازهای مفهومی (خلاصه و کاربردی)](#۲-پیش-نیازهای-مفهومی-خلاصه-و-کاربردی)
- [۳. بررسی وضعیت واقعی VPS ایران](#۳-بررسی-وضعیت-واقعی-vps-ایران)
- [۴. طراحی DNS و دامنه برای dnstt](#۴-طراحی-dns-و-دامنه-برای-dnstt)
- [۵. راه‌اندازی dnstt-server روی VPS خارج](#۵-راه-اندازی-dnstt-server-روی-vps-خارج)
- [۶. راه‌اندازی dnstt-client روی VPS ایران](#۶-راه-اندازی-dnstt-client-روی-vps-ایران)
- [۷. تبدیل این تانل به یک فیلترشکن قابل‌استفاده](#۷-تبدیل-این-تانل-به-یک-فیلترشکن-قابل-استفاده)
- [۸. ادغام با اسکریپت slipstream](#۸-ادغام-با-اسکریپت-slipstream)
- [۹. عیب‌یابی (Troubleshooting)](#۹-عیب-یابی-troubleshooting)
- [۱۰. ملاحظات امنیتی و سانسور](#۱۰-ملاحظات-امنیتی-و-سانسور)
- [۱۱. جمع‌بندی و چک‌لیست نهایی](#۱۱-جمع-بندی-و-چک-لیست-نهایی)

---

## ۱. ایده‌ی اصلی و سناریوی هدف

مدل فیلترینگ فعلی معمولاً این‌طور عمل می‌کند:

- بخش زیادی از ترافیک، زیر **DPI** و سیاست‌های «پروتکل مجاز» است؛  
- پروتکل‌های کلاسیک VPN (SSH خام، OpenVPN، WireGuard و…) به‌سادگی شناسایی و قطع می‌شوند؛  
- اما **DNS** معمولاً آخرین لایه‌ای است که به‌طور کامل بسته می‌شود، چون حذف کامل آن می‌تواند کل زیرساخت (حتی داخلی) را مختل کند.

اینجا جایی است که **dnstt** وارد بازی می‌شود:

- dnstt ترافیک شما را داخل **پیام‌های DNS / DoH / DoT** کپسوله می‌کند؛  
- روی این بستر، یک لایه‌ی **Noise** برای رمزنگاری، **KCP** برای ترنسپورت قابل اعتماد روی بستر غیرقابل‌اعتماد، و **smux** برای مولتی‌پلکس چند استریم سوار می‌شود؛  
- خروجی، یک **تانل DNS** است که از نظر ظاهری شبیه ترافیک DNS/HTTPS است، اما از نظر عملکرد، رفتاری نزدیک به یک VPN مدرن دارد.

سناریویی که این README روی آن تمرکز دارد:

```text
کاربر نهایی ⇄ (هر پروتکل مجاز) ⇄ VPS ایران ⇄ dnstt-client ⇄ DNS/DoH/DoT ⇄ dnstt-server ⇄ پراکسی ⇄ اینترنت آزاد
```

VPS داخل ایران در این سناریو **نقش کلاینت dnstt** را بازی می‌کند و می‌تواند در صورت لزوم، به‌عنوان گیت‌وی برای چندین کاربر دیگر هم عمل کند.

---

## ۲. پیش‌نیازهای مفهومی (خلاصه و کاربردی)

### ۲.۱. سه نقش اصلی در این معماری

۱. **سرور خارج (Remote Endpoint)**  
   - VPS با IP عمومی خارج از ایران؛  
   - اجراکننده‌ی `dnstt-server`؛  
   - در پشت آن، یک پراکسی (مثلاً SOCKS5 یا SSH -D یا HTTP proxy).

۲. **زیرساخت DNS**  
   - یک دامنه (مثلاً `example.com`) که دسترسی مدیریتی کامل روی آن دارید؛  
   - یک زیر‌دامنه برای تانل (مثلاً `t.example.com`) که NS آن را به سرور خودتان هدایت می‌کنید.

۳. **VPS ایران (Client Endpoint)**  
   - بدون دسترسی HTTP/HTTPS بین‌الملل؛  
   - اما با دسترسی DNS (یا DoH/DoT) به بیرون؛  
   - اجراکننده‌ی `dnstt-client` و در صورت نیاز، یک لایه پراکسی برای سرویس‌دهی به کلاینت‌ها.

### ۲.۲. ساختار لایه‌ای dnstt (به‌صورت مهندسی)

ساختار منطقی dnstt، از بالا به پایین، چیزی شبیه این است:

```text
Application (مرورگر، تلگرام، SSH، ...)
  ↓ TCP
Proxy (SOCKS/HTTP/SSH -D)
  ↓ TCP
dnstt-client
  ↓ smux (چند استریم روی یک تانل)
  ↓ KCP (ترنسپورت قابل‌اعتماد روی بستر UDP/DNS)
  ↓ Noise (رمزنگاری سرتاسری)
  ↓ DNS / DoH / DoT (روی پورت‌های 53/443/853 و ...)
  ↓ Recursive Resolvers
dnstt-server
  ↓ TCP (به سمت پراکسی یا سرویس هدف روی سرور خارج)
```

نکته‌ها:

- **Noise**، کل دیتا بین dnstt-client و dnstt-server را رمز می‌کند؛  
- **KCP** روی پیام‌های DNS یک رفتار مشابه TCP فراهم می‌کند؛  
- **smux** اجازه می‌دهد چند اتصال هم‌زمان روی یک تانل واحد داشته باشید (چند تب مرورگر، چند اپ موازی، …).

---

## ۳. بررسی وضعیت واقعی VPS ایران

قبل از هر کار، باید ببینید VPS داخل ایران واقعاً چه دسترسی‌ای دارد. این مرحله حیاتی است.

### ۳.۱. چهار حالت معمول

| حالت | توضیح | مناسب dnstt؟ |
|------|-------|---------------|
| فقط داخل، بدون DNS خارجی | نه HTTP/HTTPS بین‌الملل، نه DNS خارجی | خیر، dnstt روی این VPS قابل‌استفاده نیست |
| HTTP/HTTPS خارجی بسته، DNS خارجی فعال | درخواست وب به بیرون نمی‌رود، ولی `dig google.com` جواب می‌دهد | این حالت **ایده‌آل** برای dnstt است |
| DNS عادی بسته، DoH/DoT به چند سرور خاص باز | فقط به بعضی سرورهای DoH/DoT می‌شود وصل شد | می‌شود با مد `-doh` یا `-dot` کار کرد |
| تقریباً آزاد | محدودیت خاصی نیست | dnstt همچنان قابل استفاده است، هرچند شاید نیاز حیاتی نباشد |

### ۳.۲. تست عملی روی VPS ایران

روی VPS داخل ایران:

```bash
sudo apt update
sudo apt install -y dnsutils

dig google.com
dig google.com @8.8.8.8
dig example.com
```

بعداً، پس از تنظیم دامنه، تست روی زیر‌دامنه‌ی تانل:

```bash
dig t.example.com
dig t.example.com @8.8.8.8
```

- اگر دامنه‌های خارجی و زیر‌دامنه‌ی خودتان resolve می‌شوند، شرایط برای dnstt مهیاست؛  
- اگر هیچ DNS خارجی جواب نمی‌دهد، این VPS برای این معماری مناسب نیست.

---

## ۴. طراحی DNS و دامنه برای dnstt

فرضیات نمونه:

- دامنه: `example.com`  
- زیر‌دامنه‌ی مخصوص تانل: `t.example.com`  
- نام سرور authoritative: `tns.example.com`  
- IP سرور خارج: `203.0.113.2`

### ۴.۱. رکوردهای مورد نیاز

در پنل DNS دامنه، این رکوردها را بسازید:

| نوع | نام             | مقدار        | توضیح |
|-----|-----------------|-------------|-------|
| A   | tns.example.com | 203.0.113.2 | IP سرور خارج |
| NS  | t.example.com   | tns.example.com. | authoritative بودن سرور شما برای زون تانل |

این کار باعث می‌شود هر recursive resolver (از جمله ریزالورهای اپراتورهای ایرانی)، برای resolve کردن نام‌هایی مثل:

```text
xxxxx.t.example.com
```

مستقیم به `tns.example.com` (یعنی سرور خارج شما) وصل شود؛ جایی که dnstt-server در حال گوش‌دادن است.

تست:

```bash
dig t.example.com NS
dig t.example.com @8.8.8.8
```

---

## ۵. راه‌اندازی dnstt-server روی VPS خارج

### ۵.۱. نصب dnstt-server

روی VPS خارج (Debian/Ubuntu):

```bash
sudo apt update
sudo apt install -y git golang-go

git clone https://www.bamsoftware.com/git/dnstt.git
cd dnstt/dnstt-server
go build
# خروجی: ./dnstt-server
```

### ۵.۲. تولید کلید سرور

```bash
./dnstt-server -gen-key \
  -privkey-file server.key \
  -pubkey-file server.pub
```

- `server.key` = کلید خصوصی، فقط روی سرور خارج و با دسترسی محدود؛  
- `server.pub` = کلید عمومی، بعداً به VPS ایران داده می‌شود تا هویت سرور را در پروتکل Noise تأیید کند.

### ۵.۳. انتخاب سرویس مقصد روی سرور خارج

دو الگوی اصلی:

#### ۵.۳.1. استفاده از SOCKS5 (پیشنهاد برای استفاده عمومی)

۱. اجرای SOCKS روی `127.0.0.1:8000` (به‌عنوان خروجی محلی تانل) با SSH:

```bash
# روی سرور خارج
ssh -N -D 8000 localhost
# توجه: این SOCKS صرفاً endpoint محلی تانل است و نقش خروجی اینترنت آزاد را بازی می‌کند؛
# می‌توانید به‌جای آن از Dante یا هر SOCKS5 سرویس دیگر استفاده کنید.
```

یا با هر سرور SOCKS5 دیگر (مثل Dante).

۲. اجرا‌ی dnstt-server:

```bash
./dnstt-server \
  -udp :5300 \
  -privkey-file server.key \
  t.example.com 127.0.0.1:8000
```

در این مدل، هر اتصال از سمت dnstt-client به این SOCKS5 محلی تحویل داده می‌شود و از آن‌جا به اینترنت آزاد هدایت می‌گردد.

#### ۵.۳.2. اتصال مستقیم به SSH (برای شل)

اگر فقط به دسترسی شل نیاز دارید:

```bash
./dnstt-server \
  -udp :5300 \
  -privkey-file server.key \
  t.example.com 127.0.0.1:22
```

### ۵.۴. هدایت UDP/53 به dnstt-server

فرض می‌کنیم dnstt-server روی پورت ۵۳۰۰ UDP گوش می‌دهد و می‌خواهید ریزالورها روی پورت استاندارد ۵۳ به شما برسند:

```bash
sudo iptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 5300
```

این قانون را به‌صورت پایدار ذخیره کنید (با `iptables-persistent` یا اسکریپت بوت).

### ۵.۵. راه‌اندازی با systemd

یوزر و مسیر جدا:

```bash
sudo useradd -r -s /usr/sbin/nologin dnstt
sudo mkdir -p /opt/dnstt
sudo cp dnstt-server server.key server.pub /opt/dnstt/
sudo chown -R dnstt:dnstt /opt/dnstt
```

فایل `/etc/systemd/system/dnstt-server.service`:

```ini
[Unit]
Description=dnstt DNS tunnel server
After=network-online.target
Wants=network-online.target

[Service]
User=dnstt
Group=dnstt
WorkingDirectory=/opt/dnstt
ExecStart=/opt/dnstt/dnstt-server \
    -udp :5300 \
    -privkey-file /opt/dnstt/server.key \
    t.example.com 127.0.0.1:8000
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
```

فعال‌سازی:

```bash
sudo systemctl daemon-reload
sudo systemctl enable --now dnstt-server
sudo systemctl status dnstt-server
```

---

## ۶. راه‌اندازی dnstt-client روی VPS ایران

### ۶.۱. نصب dnstt-client

روی VPS ایران:

```bash
sudo apt update
sudo apt install -y git golang-go

git clone https://www.bamsoftware.com/git/dnstt.git
cd dnstt/dnstt-client
go build
# خروجی: ./dnstt-client
```

کپی `server.pub` از سرور خارج:

```bash
scp user@203.0.113.2:/opt/dnstt/server.pub .
```

(مسیر را با توجه به تنظیمات واقعی سرور خود تنظیم کنید.)

### ۶.۲. انتخاب نوع ترنسپورت: UDP / DoH / DoT

#### ۶.۲.۱. حالت پیشنهادی: UDP DNS

در حالتی که VPS ایران به DNS معمولی خارجی دسترسی دارد، این مدل طبیعی‌ترین و اغلب پایدارترین است.

نمونه:

```bash
./dnstt-client \
  -udp 10.10.34.34:53 \
  -pubkey-file server.pub \
  t.example.com 127.0.0.1:7000
```

توضیح پارامترها:

- `10.10.34.34:53`  
  آدرس یکی از recursive resolverهای دیتاسنتر/اپراتور که تست کرده‌اید و می‌دانید `t.example.com` را resolve می‌کند (می‌توانید از `/etc/resolv.conf` و ابزارهایی مثل `systemd-resolve --status` کمک بگیرید).

- `127.0.0.1:7000`  
  پورتی که dnstt-client روی آن برای اتصال‌های TCP لوکال گوش می‌دهد. هر اپلیکیشن یا پراکسی بالادستی، به این پورت وصل می‌شود.

#### ۶.۲.۲. حالت DoH

اگر DNS معمولی بسته است اما به یک DoH server مشخص دسترسی دارید، نمونه:

```bash
./dnstt-client \
  -doh https://dns.example.com/dns-query \
  -pubkey-file server.pub \
  t.example.com 127.0.0.1:7000
```

(آدرس DoH واقعی را جایگزین کنید.)

#### ۶.۲.۳. حالت DoT

اگر دسترسی به DoT روی پورت ۸۵۳ دارید:

```bash
./dnstt-client \
  -dot 1.1.1.1:853 \
  -pubkey-file server.pub \
  t.example.com 127.0.0.1:7000
```

در عمل، در بسیاری از زیرساخت‌ها، بستن ۸۵۳ ساده است، بنابراین این گزینه اغلب در اولویت دوم قرار می‌گیرد.

### ۶.۳. تست خام تانل با netcat

برای اطمینان از عملکرد تانل:

۱. روی سرور خارج (با فرض این‌که dnstt-server به `127.0.0.1:8000` وصل می‌کند):

```bash
sudo apt install -y ncat
ncat -l -k -v 127.0.0.1 8000
```

۲. روی VPS ایران (بعد از اجرای dnstt-client):

```bash
ncat -v 127.0.0.1 7000
```

هر متنی که در `ncat` روی VPS ایران تایپ کنید، باید در ترمینال سرور خارج (روی پورت ۸۰۰۰) مشاهده شود. اگر این اتفاق می‌افتد، یعنی تانل از منظر لایه‌های شبکه و رمزنگاری سالم است.

---

## ۷. تبدیل این تانل به یک فیلترشکن قابل‌استفاده

تا اینجا یک «لوله TCP» بین VPS ایران و سرور خارج دارید. حالا باید روی این لوله، یک **پراکسی** سوار کنید.

### ۷.۱. سناریو A: VPS ایران به‌عنوان گیت‌وی برای سایر کلاینت‌ها

معماری:

- روی **سرور خارج**:  
  - dnstt-server → `127.0.0.1:8000` (SOCKS5 یا HTTP proxy).

- روی **VPS ایران**:  
  - dnstt-client → `127.0.0.1:7000`;  
  - یک پراکسی محلی که خروجی‌اش را از طریق این تانل به سرور خارج بفرستد (مثلاً ترکیب tinyproxy + redsocks، یا SSH -D روی VPS و route کردن آن روی ۷۰۰۰).

- روی **کلاینت نهایی**:  
  - اتصال به VPS ایران با پروتکلی که هنوز از فیلتر عبور می‌کند (مثلاً Xray/Reality روی پورت ۴۴۳ یا هر روش مجاز دیگر);  
  - استفاده از پراکسی ارائه‌شده توسط VPS ایران (HTTP یا SOCKS).

### ۷.۲. سناریو B: فقط خود VPS ایران به اینترنت آزاد نیاز دارد

در این سناریو:

- روی خود VPS ایران، یک پراکسی محلی (مثلاً tinyproxy) راه می‌اندازید؛  
- ترافیک tinyproxy را با ابزارهایی مثل redsocks طوری هدایت می‌کنید که به‌جای خروج مستقیم، از `127.0.0.1:7000` خارج شود؛  
- سرویس‌های روی VPS ایران، این پراکسی را به‌عنوان گیت‌وی در نظر می‌گیرند؛  
- هیچ کاربری مستقیماً به تانل متصل نمی‌شود، و همه‌چیز داخل همان VPS می‌ماند.

---

## ۸. ادغام با اسکریپت slipstream

اسکریپت‌هایی مانند **slipstream**، در عمل نقش یک **wrapper تعاملی** روی همین معماری را بازی می‌کنند:

- از شما پارامترهایی مثل:
  - دامنه‌ی مورد استفاده برای تانل؛  
  - آدرس و پورت سرویس مقصد روی سرور (مثلاً `127.0.0.1:22` یا `127.0.0.1:8888` برای tinyproxy);  
  - آدرس ریزالور یا DoH/DoT سمت کلاینت؛  
  - پورت لوکال روی کلاینت؛
  می‌گیرند؛
- فرمان‌های `dnstt-server` و `dnstt-client` را با این پارامترها می‌سازند؛  
- در بعضی نسخه‌ها، راه‌اندازی پراکسی و تنظیمات تکمیلی (مانند اصلاح DNS محلی) را هم انجام می‌دهند.

نکته‌ی مهم:  
اگر ساختار این README را خوب بفهمید، slipstream برایتان فقط یک ابزار راحتی (automation) است، نه یک «جعبه‌ی سیاه» نامعلوم.

---

## ۹. عیب‌یابی (Troubleshooting)

### ۹.۱. dnstt-client اصلاً وصل نمی‌شود

چک‌لیست:

1. **درست بودن NS/A رکوردها**  
   - `dig t.example.com NS` باید NS درست را نشان دهد؛  
   - اگر پاسخی نمی‌آید، احتمالاً تنظیم DNS زون مشکل دارد.

2. **باز بودن UDP/53 روی سرور خارج**  
   - فایروال سیستم‌عامل یا فایروال شبکه ممکن است پورت ۵۳ را بسته باشد؛  
   - iptables برای ریدایرکت به ۵۳۰۰ باید اعمال شده و فعال باشد.

3. **کلید عمومی صحیح**  
   - `server.pub` روی کلاینت باید همان کلیدی باشد که روی سرور با آن `server.key` تولید شده؛  
   - mismatch بین این دو، در لاگ به‌صورت خطای handshake یا مشابه آن دیده می‌شود.

### ۹.۲. تانل کار می‌کند ولی بعد از چند دقیقه می‌میرد

علل محتمل:

- محدودیت نرخ (rate limiting) روی recursive resolver؛  
- MTU نامناسب که باعث fragment شدن زیاد و افت performance می‌شود.

اقدامات:

- تست ریزالورهای مختلف (در صورت امکان);  
- تنظیم دستی MTU پایین‌تر روی هر دو سمت، مثلاً:

```bash
# سرور
./dnstt-server -mtu 512 ...

# کلاینت
./dnstt-client -mtu 512 ...
```

dnstt هنگام start مقدار MTU مؤثر را لاگ می‌کند؛ این عدد باید با واقعیت شبکه شما هم‌خوانی داشته باشد.

### ۹.۳. دامنه‌ی تانل به‌صورت هدفمند بلاک یا poison می‌شود

نشانه‌ها:

- `dig t.example.com` از داخل ایران ناگهان قطع می‌شود؛  
- یا دامنه به IP اشتباهی resolve می‌شود.

راه‌حل:

- تعریف زون یا دامنه‌ی جدید (مثلاً `t2.example.com`) با NS جدید؛  
- به‌روزرسانی کانفیگ dnstt-server و dnstt-client برای دامنه‌ی جدید؛  
- اگر برای چند کاربر سرویس می‌دهید، داشتن مکانیزم امن برای اطلاع‌رسانی این تغییر ضروری است.

---

## ۱۰. ملاحظات امنیتی و سانسور

### ۱۰.۱. چه چیزهایی برای ناظر شبکه قابل مشاهده است؟

- در حالت **UDP DNS**:
  - آدرس‌های IP مبدا و مقصد؛  
  - تعداد و الگوی کوئری‌ها؛  
  - اسامی دامنه‌ها (اگر رمزگذاری سطح نام اعمال نشده باشد);  
  - اندازه‌ی پیام‌ها و فرکانس رفت‌وبرگشت.

- در حالت **DoH/DoT**:
  - IP مقصد و اطلاعات پروتکل TLS/HTTPS (مثل SNI، در صورت عدم استفاده از ESNI/Encrypted Client Hello);  
  - الگوی کلی حجم و زمان‌بندی پکت‌ها.

در همه‌ی حالت‌ها، محتوای واقعی تانل (دیتای اپلیکیشن) داخل لایه‌ی Noise رمز شده و برای ناظر قابل خواندن نیست، اما الگوی ترافیکی همچنان قابل مشاهده و تحلیل آماری است.

### ۱۰.۲. کاهش ریسک شناسایی و بلاک

چند توصیه عملی:

- استفاده از دامنه‌هایی که از نظر ظاهری و کاربرد، نرمال و بدون حساسیت خاص باشند;  
- نگه‌داشتن مصرف تانل در سطح منطقی و عدم استفاده برای دانلودهای بسیار سنگین و مداوم;  
- طراحی از ابتدا با در نظر گرفتن مهاجرت سریع دامنه (Zonename rotation);  
- محافظت از خود VPS ایران و پراکسی‌های روی آن با احراز هویت مناسب (پسورد قوی، TLS، گواهی معتبر، …).

---

## ۱۱. جمع‌بندی و چک‌لیست نهایی

برای این‌که بتوانید این آموزش را به‌عنوان یک راهنمای اجرایی روی سرورهای خودتان استفاده کنید، کل مسیر را در قالب یک چک‌لیست خلاصه می‌کنیم:

1. **بررسی VPS ایران**
   - نصب `dnsutils`;  
   - اجرای `dig google.com` و `dig example.com`;  
   - اگر DNS خارجی در دسترس نیست، این VPS برای این معماری مناسب نیست.

2. **آماده‌سازی DNS**
   - انتخاب دامنه (مثلاً `example.com`);  
   - تعریف `tns.example.com` (A → IP سرور خارج);  
   - تعریف `NS` برای `t.example.com` به‌سمت `tns.example.com`.

3. **سرور خارج**
   - نصب Go و build کردن `dnstt-server`;  
   - تولید `server.key` و `server.pub`;  
   - راه‌اندازی یک پراکسی (مثلاً SSH -D روی پورت ۸۰۰۰);  
   - اجرای `dnstt-server` روی `-udp :5300` و مقصد `127.0.0.1:8000`;  
   - تنظیم iptables برای هدایت UDP/53 به ۵۳۰۰;  
   - قرار دادن سرویس زیر systemd با یوزر محدود.

4. **VPS ایران**
   - نصب Go و build کردن `dnstt-client`;  
   - کپی `server.pub` از سرور خارج;  
   - اجرای `dnstt-client` با یکی از حالت‌های `-udp`، `-doh` یا `-dot` و لیسن روی `127.0.0.1:7000`.

5. **تست تانل**
   - اجرای `ncat -l -k -v 127.0.0.1 8000` روی سرور;  
   - اجرای `ncat -v 127.0.0.1 7000` روی VPS ایران;  
   - تأیید عبور داده‌ی ساده بین دو طرف.

6. **ساخت فیلترشکن**
   - سوار کردن یک پراکسی روی VPS ایران که خروجی‌اش به‌طور مستقیم یا غیرمستقیم روی `127.0.0.1:7000` برود;  
   - اتصال کلاینت‌ها به VPS ایران، و تنظیم مرورگر/سیستم برای استفاده از آن پراکسی.

7. **در صورت نیاز: استفاده از slipstream**
   - برای اتومات‌کردن تولید کامندهای dnstt و راه‌اندازی سریع‌تر;  
   - با این درک که در لایه‌ی زیرین، همان معماری dnstt + DNS + پراکسی در حال کار است.
